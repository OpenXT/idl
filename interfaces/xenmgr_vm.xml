<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
<node xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0" name="/vm/uuid">
  <tp:enum name="VIRT_TYPE" type="s">
    <!--Xen virtualization type.-->
    <tp:enumvalue suffix="PV" value="pv"/>
    <tp:enumvalue suffix="PVH" value="pvh"/>
    <tp:enumvalue suffix="HVM" value="hvm"/>
  </tp:enum>
  <!--~~~~~~~~~~~~~~~~~~~~~~
  ~~~~  DBus Interface  ~~~~
  ~~~~~~~~~~~~~~~~~~~~~~~-->
  <interface name="com.citrix.xenclient.xenmgr.vm">
    <!--VM interface. Property access goes through policy checks.-->
    <!--One of pv, pvh, or hvm.-->
    <!--~~~~~~~~~~~~~~~~~~~~~~
    ~~~~  DBus Methods    ~~~~
    ~~~~~~~~~~~~~~~~~~~~~~~-->
    <method name="add_argo_firewall_rule">
      <arg name="rule" type="s" direction="in"/>
    </method>
    <method name="add_disk">
      <!--Add a new disk to VM.-->
      <arg name="path" type="o" direction="out"/>
    </method>
    <method name="add_net_firewall_rule">
      <arg name="id" type="i" direction="in"/>
      <arg name="direction" type="s" direction="in"/>
      <arg name="remoteip" type="s" direction="in"/>
      <arg name="extra" type="s" direction="in"/>
    </method>
    <method name="add_nic">
      <!--Add a new NIC to the VM.-->
      <arg name="path" type="o" direction="out"/>
    </method>
    <method name="create_child_service_vm">
      <!--Create a subordinate Service VM.-->
      <arg name="template" type="s" direction="in"/>
      <arg name="path" type="o" direction="out"/>
    </method>
    <method name="delete">
      <!--Remove a VM.-->
    </method>
    <method name="delete_argo_firewall_rule">
      <arg name="rule" type="s" direction="in"/>
    </method>
    <method name="delete_net_firewall_rule">
      <arg name="id" type="i" direction="in"/>
    </method>
    <method name="destroy">
      <!--Force shutdown the VM.-->
    </method>
    <method name="get_db_key">
      <!--Get the value of a VM db key.-->
      <arg name="key" type="s" direction="in"/>
      <arg name="value" type="s" direction="out"/>
    </method>
    <method name="get_domstore_key">
      <!--Get the value of a VM domstore (domain accessible disk-based private storage) key.-->
      <arg name="key" type="s" direction="in"/>
      <arg name="value" type="s" direction="out"/>
    </method>
    <method name="hibernate">
      <!--s4 the VM.-->
    </method>
    <method name="list_argo_firewall_rules">
      <arg name="rules" type="as" direction="out"/>
    </method>
    <method name="list_disks">
      <!--List the disk objects attached to this VM.-->
      <arg name="" type="ao" direction="out"/>
    </method>
    <method name="list_net_firewall_rules">
      <arg name="rules" type="aa{ss}" direction="out"/>
      <annotation name="org.qtproject.QtDBus.QtTypeName.Out0" value="QList&lt;QMap&lt;QString,QString&gt;&gt;"/>
    </method>
    <method name="list_nics">
      <!--List the NIC objects attached to the VM.-->
      <arg name="" type="ao" direction="out"/>
    </method>
    <method name="pause">
      <!--Pause VM execution-->
    </method>
    <method name="read_icon">
      <!--Read a byte array representing the VM icon image.-->
      <arg name="bytes" type="ay" direction="out"/>
    </method>
    <method name="reboot">
      <!--Reboot the VM.-->
    </method>
    <method name="resume">
      <!--Wake the VM from s3.-->
    </method>
    <method name="resume_from_file">
      <!--Resume the VM from a suspended disk image.-->
      <arg name="file" type="s" direction="in"/>
    </method>
    <method name="set_db_key">
      <!--Set the value of a VM db key.-->
      <arg name="key" type="s" direction="in"/>
      <arg name="value" type="s" direction="in"/>
    </method>
    <method name="set_domstore_key">
      <!--Set the value of a VM domstore (domain accessible disk-based private storage) key.-->
      <arg name="key" type="s" direction="in"/>
      <arg name="value" type="s" direction="in"/>
    </method>
    <method name="shutdown">
      <!--Shutdown the VM.-->
    </method>
    <method name="sleep">
      <!--s3 the VM.-->
    </method>
    <method name="start">
      <!--Start the VM.-->
    </method>
    <method name="start_internal">
      <!--Start the VM, for internal use (bypass start hook)-->
    </method>
    <method name="suspend_to_file">
      <!--Suspend the  VM to disk.-->
      <arg name="file" type="s" direction="in"/>
    </method>
    <method name="switch">
      <!--Switch to a VM.-->
    </method>
    <method name="unpause">
      <!--Resume VM execution from paused state-->
    </method>
    <!--~~~~~~~~~~~~~~~~~~~~~~
    ~~~~  DBus Properties ~~~~
    ~~~~~~~~~~~~~~~~~~~~~~~-->
    <property name="acpi" type="b" access="readwrite"/>
    <property name="acpi-state" type="i" access="read"/>
    <property name="acpi-table" type="b" access="readwrite">
      <!--Enable OEM windows install by exposing the ACPI SLIC table.-->
    </property>
    <property name="amt-pt" type="b" access="readwrite"/>
    <property name="apic" type="b" access="readwrite"/>
    <property name="argo" type="b" access="readwrite">
      <!--Use Argo.-->
    </property>
    <property name="authenforce" type="b" access="readwrite">
      <!--Enable or disable Authentication enforcement mode in UEFI guest VMs.-->
    </property>
    <property name="auto-s3-wake" type="b" access="readwrite"/>
    <property name="autostart-pending" type="b" access="read"/>
    <property name="bios" type="s" access="readwrite">
      <!--Bios specification-->
    </property>
    <property name="boot" type="s" access="readwrite"/>
    <property name="boot-sentinel" type="s" access="readwrite">
      <!--Name of xenstore node to wait on before completing vm startup from toolstack PoV. Useful if VM exports services which need to be immediately usable by other vms-->
    </property>
    <property name="cd" type="s" access="readwrite"/>
    <property name="cmd-line" type="s" access="readwrite"/>
    <property name="control-platform-power-state" type="b" access="readwrite">
      <!--If set, the entire platform will go into S3/S4/S5 when this VM goes into S3/S4/S5.-->
    </property>
    <property name="cores-per-socket" type="i" access="readwrite"/>
    <property name="cpuid" type="s" access="readwrite">
      <!--Used to set/unset certain bits in response to CPUID instruction.-->
    </property>
    <property name="crypto-key-dirs" type="s" access="readwrite">
      <!--Comma-separated list of disk encryption keys directories.-->
    </property>
    <property name="crypto-user" type="s" access="readwrite"/>
    <property name="dependencies" type="ao" access="read">
      <!--VMs that are required to be running before starting this one.-->
    </property>
    <property name="description" type="s" access="readwrite"/>
    <property name="display" type="s" access="readwrite"/>
    <property name="domid" type="i" access="read"/>
    <property name="domstore-read-access" type="b" access="readwrite">
      <!--Configure domain read access to domstore.-->
    </property>
    <property name="domstore-write-access" type="b" access="readwrite">
      <!--Configure domain write access to domstore.-->
    </property>
    <property name="download-progress" type="i" access="readwrite">
      <!--VM download progress.-->
    </property>
    <property name="extra-hvm" type="s" access="readwrite">
      <!--Extra ioemu arguments, separated by semicolons.-->
    </property>
    <property name="extra-xenvm" type="s" access="readwrite">
      <!--Extra xenvm arguments, separated by semicolons.-->
    </property>
    <property name="flask-label" type="s" access="readwrite"/>
    <property name="gpu" type="s" access="readwrite"/>
    <property name="greedy-pciback-bind" type="b" access="readwrite">
      <!--Bind passthrough pci devices to pciback early, to prevent their use by other VMs.-->
    </property>
    <property name="hap" type="b" access="readwrite"/>
    <property name="hdtype" type="s" access="readwrite">
      <!--Hard disk type specification, 'ide' or 'ahci'-->
    </property>
    <property name="hibernated" type="b" access="read"/>
    <property name="hidden-in-switcher" type="b" access="readwrite"/>
    <property name="hidden-in-ui" type="b" access="readwrite"/>
    <property name="hpet" type="b" access="readwrite">
      <!--HPET support-->
    </property>
    <property name="icbinn-path" type="s" access="readwrite">
      <!--Filesystem path exported to the VM via icbinn server.-->
    </property>
    <property name="image-path" type="s" access="readwrite"/>
    <property name="init-flask-label" type="s" access="readwrite"/>
    <property name="initrd" type="s" access="readwrite"/>
    <property name="initrd-extract" type="s" access="readwrite">
      <!--[disk_number,partition_number:]/path/to/initrd
	Location of initrd image within the VM's disk(s). Examples:
	  /boot/inird (/boot/inird in unpartitioned disk 0)
	  2:/boot/inird (/boot/inird in unpartitioned disk 2)
	  0,1:/boot/inird (/boot/inird in 1st partitin of disk 0)
      -->
    </property>
    <property name="keep-alive" type="b" access="readwrite">
      <!--Automatically restart this VM if it shuts down or crashes.-->
    </property>
    <property name="kernel" type="s" access="readwrite"/>
    <property name="kernel-extract" type="s" access="readwrite">
      <!--[disk_number,partition_number:]/path/to/kernel
	Location of kernel image within the VM's disk(s). Examples:
	  /boot/vmlinuz (/boot/vmlinuz in unpartitioned disk 0)
	  2:/boot/vmlinuz (/boot/vmlinuz in unpartitioned disk 2)
	  0,1:/boot/vmlinuz (/boot/vmlinuz in 1st partitin of disk 0)
      -->
    </property>
    <property name="display-handler-strict" type="b" access="readwrite">
      <!--Strict checking for information about a VM's domain specific information (color, name, nickname)-->
    </property>
    <property name="image_path_vg" type="s" access="readwrite">
      <!--Path to the icon used to represent the VM in the UI.-->
    </property>
    <property name="long_form_vg" type="s" access="readwrite">
      <!--Label displayed on the overlay to identify the VM. This cannot exceed around 3/5th of the total width of the display or the short version will be used instead.-->
    </property>
    <property name="short_form_vg" type="s" access="readwrite">
      <!--Abreviated (short) lavel displayed on the overlay to identify the VM. This is only displayed if long_form_vg is too long (its rendered size is close to 3/5th of the display width). If the short format is too long still, it is truncated.-->
    </property>
    <property name="text_color_vg" type="s" access="readwrite">
      <!--Label text color given in RGB (e.g, #ff0000).-->
    </property>
    <property name="border_width_vg" type="i" access="readwrite">
      <!--Unused-->
    </property>
    <property name="border_height_vg" type="i" access="readwrite">
      <!--Unused-->
    </property>
    <property name="vglass_enabled" type="b" access="readwrite">
      <!--Bool for vglass to create vm object-->
    </property>
    <property name="mosaic_mode" type="i" access="readwrite">
      <!--VM mode for mosaic (seamless = 1, windowed = 2, pinned = 4)-->
    </property>
    <property name="windowed_x" type="i" access="readwrite">
      <!--Last x coord of windowed mode (mosaic-windowed only)-->
    </property>
    <property name="windowed_y" type="i" access="readwrite">
      <!--Last y coord of windowed mode (mosaic-windowed only)-->
    </property>
    <property name="windowed_w" type="i" access="readwrite">
      <!--Last width of windowed mode (mosaic-windowed only)-->
    </property>
    <property name="windowed_h" type="i" access="readwrite">
      <!--Last height of windowed mode (mosaic-windowed only)-->
    </property>
    <property name="primary_domain_color" type="s" access="readwrite">
      <!--Primary color for decorations, the background of the overlay bar given in RGB (e.g, #ff0000).-->
    </property>
    <property name="secondary_domain_color" type="s" access="readwrite">
      <!--Secondary color for decorations, the separators of the overlay bar given in RGB (e.g, #ff0000).-->
    </property>
    <property name="mosaic_vm_enabled" type="b" access="readwrite">
      <!--Bool for determining if a vm mosaic mode can change-->
    </property>
    <property name="mac" type="s" access="read"/>
    <property name="measured" type="b" access="read">
      <!--If the VM is measured, the hash of the disk image is checked before it is allowed to start.-->
    </property>
    <property name="memory" type="i" access="readwrite"/>
    <property name="memory-min" type="i" access="readwrite"/>
    <property name="memory-static-max" type="i" access="readwrite"/>
    <property name="memory-target" type="i" access="read"/>
    <property name="name" type="s" access="readwrite"/>
    <property name="native-experience" type="b" access="readwrite">
      <!--Toggle 'native experience' on/onff.-->
    </property>
    <property name="nestedhvm" type="b" access="readwrite">
      <!--Enable nested virtualization-->
    </property>
    <property name="notify" type="s" access="readwrite"/>
    <property name="nx" type="b" access="readwrite"/>
    <property name="oem-acpi-features" type="b" access="readwrite">
      <!--Enables access to additional OEM acpi features.-->
    </property>
    <property name="os" type="s" access="readwrite"/>
    <property name="ovf-transport-iso" type="b" access="readwrite">
      <!--Transport of OVF configuration via iso enabled yes/no.-->
    </property>
    <property name="pae" type="b" access="readwrite"/>
    <property name="passthrough-io" type="s" access="readwrite"/>
    <property name="passthrough-mmio" type="s" access="readwrite"/>
    <property name="policy-audio-access" type="b" access="readwrite">
      <!--Allow VM to playback audio.-->
    </property>
    <property name="policy-audio-recording" type="b" access="readwrite">
      <!--Allow VM to record audio.-->
    </property>
    <property name="policy-cd-access" type="b" access="readwrite">
      <!--Allow VM to read from CD.-->
    </property>
    <property name="policy-cd-recording" type="b" access="readwrite">
      <!--Allow VM to burn CDs.-->
    </property>
    <property name="policy-modify-vm-settings" type="b" access="readwrite">
      <!--Allow modification of VM settings.-->
    </property>
    <property name="policy-print-screen" type="b" access="readwrite">
      <!--Allow VM to use the PrintScreen key.-->
    </property>
    <property name="policy-wired-networking" type="b" access="readwrite">
      <!--Allow VM to access wired network.-->
    </property>
    <property name="policy-wireless-networking" type="b" access="readwrite">
      <!--Allow VM to access wireless network.-->
    </property>
    <property name="portica-enabled" type="i" access="read"/>
    <property name="portica-installed" type="b" access="read"/>
    <property name="preserve-on-reboot" type="b" access="readwrite">
      <!--After reboot, keep the vm in rebooted state instead of automatically restarting it-->
    </property>
    <property name="private-space" type="i" access="read">
      <!--Private space used (in MiB).-->
    </property>
    <property name="provides-default-network-backend" type="b" access="readwrite">
      <!--Whether this domain is the primary networking backend and handles the physical NIC devices.-->
    </property>
    <property name="provides-graphics-fallback" type="b" access="readwrite">
      <!--System will keep this VM on screen when no better candidate is present.-->
    </property>
    <property name="provides-network-backend" type="b" access="readwrite">
      <!--Whether this domain is a networking backend and handles the physical NIC devices.-->
    </property>
    <property name="pv-addons" type="b" access="readwrite"/>
    <property name="pv-addons-version" type="s" access="readwrite"/>
    <property name="qemu-dm-path" type="s" access="readwrite"/>
    <property name="qemu-dm-timeout" type="i" access="readwrite">
      <!--Timeout (in seconds) to wait for qemu response during qemu startup.-->
    </property>
    <property name="ready" type="b" access="readwrite">
      <!--Is VM ready for use?-->
    </property>
    <property name="realm" type="s" access="readwrite">
      <!--Realm ID.-->
    </property>
    <property name="restrict-display-depth" type="b" access="readwrite">
      <!--Restrict available display depths. Currently required by emulated VGA in Windows 8.-->
    </property>
    <property name="restrict-display-res" type="b" access="readwrite">
      <!--Restrict available display resolutions.-->
    </property>
    <property name="run-insteadof-start" type="s" access="readwrite">
      <!--Command to run instead of VM start-->
    </property>
    <property name="run-on-acpi-state-change" type="s" access="readwrite">
      <!--Command to run on VM acpi state change.-->
    </property>
    <property name="run-on-state-change" type="s" access="readwrite">
      <!--Command to run on VM state change.-->
    </property>
    <property name="run-post-create" type="s" access="readwrite">
      <!--Command to run post VM creation.-->
    </property>
    <property name="run-pre-boot" type="s" access="readwrite">
      <!--Command to run synchronously pre VM boot.-->
    </property>
    <property name="run-pre-delete" type="s" access="readwrite">
      <!--Command to run pre VM deletion.-->
    </property>
    <property name="s3-mode" type="s" access="readwrite">
      <!--Configure how the VM is put to sleep.-->
    </property>
    <property name="s4-mode" type="s" access="readwrite">
      <!--Configure how the VM is hibernated.-->
    </property>
    <property name="seamless-id" type="s" access="readwrite">
      <!--Handle seamless uses to reference the VMs.-->
    </property>
    <property name="seamless-mouse-left" type="i" access="read">
      <!--Where to move mouse when it goes over the left edge of a surface.-->
    </property>
    <property name="seamless-mouse-right" type="i" access="read">
      <!--Where to move mouse when it goes over right edge of a surface.-->
    </property>
    <property name="seamless-traffic" type="b" access="readwrite"/>
    <property name="secureboot" type="b" access="readwrite">
      <!--Enable or disable Secure Boot mode in UEFI guest VMs.-->
    </property>
    <property name="serial" type="s" access="readwrite">
      <!--Serial port specification-->
    </property>
    <property name="show-switcher" type="b" access="readwrite">
      <!--Hide/show switcher bar inside VM.-->
    </property>
    <property name="shutdown-priority" type="i" access="readwrite">
      <!--Controls the order of VM shutdown, higher priority means earlier shutdown. For new VMs defaults to 0, or -10 in case of PVM. VMs with the same priority are shutdown in parallel.-->
    </property>
    <property name="slot" type="i" access="readwrite"/>
    <property name="sound" type="s" access="readwrite"/>
    <property name="start-from-suspend-image" type="s" access="readwrite">
      <!--Start VM from suspend image file, if it exists.-->
    </property>
    <property name="start-on-boot" type="b" access="readwrite"/>
    <property name="start-on-boot-priority" type="i" access="readwrite">
      <!--Control priority of start-on-boot VMs, higher priority means earlier start. Defaults to 0 for new VMs.-->
    </property>
    <property name="state" type="s" access="read"/>
    <property name="stubdom" type="b" access="readwrite">
      <!--Use stub domain to hide the device emulator.-->
    </property>
    <property name="stubdom-flask-label" type="s" access="readwrite"/>
    <property name="sync-uuid" type="s" access="readwrite">
      <!--VM UUID in synchroniser space.-->
    </property>
    <property name="time-offset" type="i" access="readwrite"/>
    <property name="timer-mode" type="s" access="readwrite">
      <!--Domain timer mode-->
    </property>
    <property name="track-dependencies" type="b" access="readwrite">
      <!--If true, automatically start required VMs.-->
    </property>
    <property name="type" type="s" access="readwrite"/>
    <property name="usb-auto-passthrough" type="b" access="readwrite">
      <!--Enables automatic passthrough of new USB devices to VM currently in focus upon plugging in.-->
    </property>
    <property name="usb-control" type="b" access="readwrite">
      <!--Enables the VM to communicate with the USB daemon.-->
    </property>
    <property name="usb-enabled" type="b" access="readwrite">
      <!--Enables PV USB support.-->
    </property>
    <property name="usb-grab-devices" type="b" access="readwrite">
      <!--Automatically assign all available USB devices upon this VM start.-->
    </property>
    <property name="uuid" type="s" access="read"/>
    <property name="vcpus" type="i" access="readwrite"/>
    <property name="videoram" type="i" access="readwrite"/>
    <property name="viridian" type="b" access="readwrite"/>
    <property name="virt-type" type="s" access="readwrite"/>
    <property name="vkbd" type="b" access="readwrite">
      <!--Use PV keyboard and mouse.-->
    </property>
    <property name="vsnd" type="b" access="readwrite">
      <!--Use PV audio device.-->
    </property>
    <property name="wired-network" type="s" access="readwrite"/>
    <property name="wireless-control" type="b" access="readwrite">
      <!--Give VM control over wireless stack.-->
    </property>
    <property name="wireless-network" type="s" access="readwrite"/>
    <property name="xci-cpuid-signature" type="b" access="readwrite">
      <!--Advertise to guest as XenClient flavour of Xen.-->
    </property>
  </interface>
  <!--~~~~~~~~~~~~~~~~~~~~~~
  ~~~~  DBus Interface  ~~~~
  ~~~~~~~~~~~~~~~~~~~~~~~-->
  <interface name="com.citrix.xenclient.xenmgr.vm.auth">
    <!--Authentication Interface-->
    <!--~~~~~~~~~~~~~~~~~~~~~~
    ~~~~  DBus Methods    ~~~~
    ~~~~~~~~~~~~~~~~~~~~~~~-->
    <method name="auth">
      <!--Attempt to authenticate to VM.-->
    </method>
    <method name="auth_required">
      <!--Check if authentication to VM is required.-->
      <arg name="required" type="b" direction="out"/>
    </method>
  </interface>
  <!--~~~~~~~~~~~~~~~~~~~~~~
  ~~~~  DBus Interface  ~~~~
  ~~~~~~~~~~~~~~~~~~~~~~~-->
  <interface name="com.citrix.xenclient.xenmgr.vm.pci">
    <!--Manipulate passthrough lists.-->
    <!--~~~~~~~~~~~~~~~~~~~~~~
    ~~~~  DBus Methods    ~~~~
    ~~~~~~~~~~~~~~~~~~~~~~~-->
    <method name="add_pt_rule">
      <!--Add PCI passthrough rule. Passing empty string in one of the arguments (class,vendor,device) turns off matching on that argument.-->
      <arg name="pciclass" type="s" direction="in"/>
      <arg name="vendor_id" type="s" direction="in"/>
      <arg name="device_id" type="s" direction="in"/>
    </method>
    <method name="add_pt_rule_bdf">
      <!--Add PCI passthrough rule. Specify device using BDF syntax (e.g.: 0000:00:16.0).-->
      <arg name="bdf" type="s" direction="in"/>
    </method>
    <method name="delete_pt_rule">
      <!--Remove passthrough rule(s).-->
      <arg name="pciclass" type="s" direction="in"/>
      <arg name="vendor_id" type="s" direction="in"/>
      <arg name="device_id" type="s" direction="in"/>
    </method>
    <method name="delete_pt_rule_bdf">
      <!--Remove PCI passthrough rule using BDF syntax.-->
      <arg name="bdf" type="s" direction="in"/>
    </method>
    <method name="list_pt_pci_devices">
      <!--List PCI devices which match current passthrough rules.-->
      <arg name="" type="aa{ss}" direction="out"/>
      <annotation name="org.qtproject.QtDBus.QtTypeName.Out0" value="QList&lt;QMap&lt;QString,QString&gt;&gt;"/>
    </method>
    <method name="list_pt_rules">
      <!--List current passthrough rules in effect.-->
      <arg name="" type="aa{ss}" direction="out"/>
      <annotation name="org.qtproject.QtDBus.QtTypeName.Out0" value="QList&lt;QMap&lt;QString,QString&gt;&gt;"/>
    </method>
  </interface>
  <!--~~~~~~~~~~~~~~~~~~~~~~
  ~~~~  DBus Interface  ~~~~
  ~~~~~~~~~~~~~~~~~~~~~~~-->
  <interface name="com.citrix.xenclient.xenmgr.vm.product">
    <!--Configuration of products (services) in the VM.-->
    <!--~~~~~~~~~~~~~~~~~~~~~~
    ~~~~  DBus Methods    ~~~~
    ~~~~~~~~~~~~~~~~~~~~~~~-->
    <method name="get_ovf_env_xml">
      <!--Return the OVF environment xml.-->
      <arg name="value" type="s" direction="out"/>
    </method>
    <method name="get_product_property">
      <!--Query product property value.-->
      <arg name="property_id" type="s" direction="in"/>
      <arg name="value" type="s" direction="out"/>
    </method>
    <method name="list_product_properties">
      <!--List all product properties for this VM.-->
      <arg name="product_properties" type="aa{ss}" direction="out"/>
      <annotation name="org.qtproject.QtDBus.QtTypeName.Out0" value="QList&lt;QMap&lt;QString,QString&gt;&gt;"/>
    </method>
    <method name="set_product_property">
      <!--Change product property value.-->
      <arg name="property_id" type="s" direction="in"/>
      <arg name="value" type="s" direction="in"/>
    </method>
  </interface>
  <!--~~~~~~~~~~~~~~~~~~~~~~
  ~~~~  DBus Interface  ~~~~
  ~~~~~~~~~~~~~~~~~~~~~~~-->
  <interface name="com.citrix.xenclient.xenmgr.vm.unrestricted">
    <!--Allows unrestricted access to VM properties (without policy checks) so daemons in the control domain (dom0) can easily change settings.-->
    <!--One of pv, pvh, or hvm.-->
    <!--~~~~~~~~~~~~~~~~~~~~~~
    ~~~~  DBus Properties ~~~~
    ~~~~~~~~~~~~~~~~~~~~~~~-->
    <property name="acpi" type="b" access="readwrite"/>
    <property name="acpi-state" type="i" access="read"/>
    <property name="acpi-table" type="b" access="readwrite">
      <!--Enable OEM windows installation by exposing the ACPI SLIC table.-->
    </property>
    <property name="amt-pt" type="b" access="readwrite"/>
    <property name="apic" type="b" access="readwrite"/>
    <property name="argo" type="b" access="readwrite">
      <!--Use Argo.-->
    </property>
    <property name="authenforce" type="b" access="readwrite">
      <!--Enable or disable Authentication enforcement mode in UEFI guest VMs.-->
    </property>
    <property name="auto-s3-wake" type="b" access="readwrite"/>
    <property name="autostart-pending" type="b" access="read"/>
    <property name="bios" type="s" access="readwrite">
      <!--Bios specification-->
    </property>
    <property name="boot" type="s" access="readwrite"/>
    <property name="boot-sentinel" type="s" access="readwrite">
      <!--Name of xenstore node to wait on before completing vm startup from toolstack PoV. Useful if VM exports services which need to be immediately usable by other vms-->
    </property>
    <property name="cd" type="s" access="readwrite"/>
    <property name="cmd-line" type="s" access="readwrite"/>
    <property name="control-platform-power-state" type="b" access="readwrite">
      <!--If set, whole platform will go into S3/S4/S5 when this VM goes into S3/S4/S5.-->
    </property>
    <property name="cores-per-socket" type="i" access="readwrite"/>
    <property name="cpuid" type="s" access="readwrite">
      <!--Used to set/unset certain bits in response to CPUID instruction.-->
    </property>
    <property name="crypto-key-dirs" type="s" access="readwrite">
      <!--Comma-separated list of disk encryption keys directories.-->
    </property>
    <property name="crypto-user" type="s" access="readwrite"/>
    <property name="dependencies" type="ao" access="read">
      <!--VMs that are required to be running before starting this one.-->
    </property>
    <property name="description" type="s" access="readwrite"/>
    <property name="display" type="s" access="readwrite"/>
    <property name="domid" type="i" access="read"/>
    <property name="domstore-read-access" type="b" access="readwrite">
      <!--Configure domain read access to domstore.-->
    </property>
    <property name="domstore-write-access" type="b" access="readwrite">
      <!--Configure domain write access to domstore.-->
    </property>
    <property name="download-progress" type="i" access="readwrite">
      <!--VM download progress.-->
    </property>
    <property name="extra-hvm" type="s" access="readwrite">
      <!--Extra ioemu arguments separated by semicolon.-->
    </property>
    <property name="extra-xenvm" type="s" access="readwrite">
      <!--Extra xenvm arguments separated by semicolon.-->
    </property>
    <property name="flask-label" type="s" access="readwrite"/>
    <property name="gpu" type="s" access="readwrite"/>
    <property name="greedy-pciback-bind" type="b" access="readwrite">
      <!--Bind passthrough pci devices to pciback early, to prevent their use by other VMs.-->
    </property>
    <property name="hap" type="b" access="readwrite"/>
    <property name="hdtype" type="s" access="readwrite">
      <!--Hard disk type specification, 'ide' or 'ahci'-->
    </property>
    <property name="hibernated" type="b" access="read"/>
    <property name="hidden-in-switcher" type="b" access="readwrite"/>
    <property name="hidden-in-ui" type="b" access="readwrite"/>
    <property name="hpet" type="b" access="readwrite">
      <!--HPET support-->
    </property>
    <property name="display-handler-strict" type="b" access="readwrite">
      <!--Strict checking for information about a VM's domain specific information (color, name, nickname)-->
    </property>
    <property name="stub_domid" type="i" access="read"/>
    <property name="image_path_vg" type="s" access="readwrite">
      <!--Path to the icon used to represent the VM in the UI.-->
    </property>
    <property name="long_form_vg" type="s" access="readwrite">
      <!--Label displayed on the overlay to identify the VM. This cannot exceed around 3/5th of the total width of the display or the short version will be used instead.-->
    </property>
    <property name="short_form_vg" type="s" access="readwrite">
      <!--Abreviated (short) lavel displayed on the overlay to identify the VM. This is only displayed if long_form_vg is too long (its rendered size is close to 3/5th of the display width). If the short format is too long still, it is truncated.-->
    </property>
    <property name="text_color_vg" type="s" access="readwrite">
      <!--Label text color given in RGB (e.g, #ff0000).-->
    </property>
    <property name="border_width_vg" type="i" access="readwrite">
      <!--Unused-->
    </property>
    <property name="border_height_vg" type="i" access="readwrite">
      <!--Unused-->
    </property>
    <property name="vglass_enabled" type="b" access="readwrite">
      <!--Bool for vglass to create vm object-->
    </property>
    <property name="mosaic_mode" type="i" access="readwrite">
      <!--VM mode for mosaic (seamless = 1, windowed = 2, pinned = 4)-->
    </property>
    <property name="windowed_x" type="i" access="readwrite">
      <!--Last x coord of windowed mode (mosaic-windowed only)-->
    </property>
    <property name="windowed_y" type="i" access="readwrite">
      <!--Last y coord of windowed mode (mosaic-windowed only)-->
    </property>
    <property name="windowed_w" type="i" access="readwrite">
      <!--Last width of windowed mode (mosaic-windowed only)-->
    </property>
    <property name="windowed_h" type="i" access="readwrite">
      <!--Last height of windowed mode (mosaic-windowed only)-->
    </property>
    <property name="primary_domain_color" type="s" access="readwrite">
      <!--Primary Color for decorations-->
    </property>
    <property name="secondary_domain_color" type="s" access="readwrite">
      <!--Secondary Color for decorations-->
    </property>
    <property name="mosaic_vm_enabled" type="b" access="readwrite">
      <!--Bool for determining if a vm mosaic mode can change-->
    </property>
    <property name="icbinn-path" type="s" access="readwrite">
      <!--Filesystem path exported to the VM via icbinn server.-->
    </property>
    <property name="image-path" type="s" access="readwrite"/>
    <property name="init-flask-label" type="s" access="readwrite"/>
    <property name="initrd" type="s" access="readwrite"/>
    <property name="initrd-extract" type="s" access="readwrite">
      <!--[disk_number,partition_number:]/path/to/initrd
	Location of initrd image within the VM's disk(s). Examples:
	  /boot/inird (/boot/inird in unpartitioned disk 0)
	  2:/boot/inird (/boot/inird in unpartitioned disk 2)
	  0,1:/boot/inird (/boot/inird in 1st partitin of disk 0)
      -->
    </property>
    <property name="keep-alive" type="b" access="readwrite">
      <!--Automatically restart this VM if it shuts down or crashes.-->
    </property>
    <property name="kernel" type="s" access="readwrite"/>
    <property name="kernel-extract" type="s" access="readwrite">
      <!--[disk_number,partition_number:]/path/to/kernel
	Location of kernel image within the VM's disk(s). Examples:
	  /boot/vmlinuz (/boot/vmlinuz in unpartitioned disk 0)
	  2:/boot/vmlinuz (/boot/vmlinuz in unpartitioned disk 2)
	  0,1:/boot/vmlinuz (/boot/vmlinuz in 1st partitin of disk 0)
      -->
    </property>
    <property name="mac" type="s" access="read"/>
    <property name="measured" type="b" access="read">
      <!--if VM is measured, the hash of the disk image is checked before it is allowed to start.-->
    </property>
    <property name="memory" type="i" access="readwrite"/>
    <property name="memory-min" type="i" access="readwrite"/>
    <property name="memory-static-max" type="i" access="readwrite"/>
    <property name="memory-target" type="i" access="read"/>
    <property name="name" type="s" access="readwrite"/>
    <property name="native-experience" type="b" access="readwrite">
      <!--Toggle 'native experience' on/off.-->
    </property>
    <property name="nestedhvm" type="b" access="readwrite">
      <!--Enable nested virtualization-->
    </property>
    <property name="notify" type="s" access="readwrite"/>
    <property name="nx" type="b" access="readwrite"/>
    <property name="oem-acpi-features" type="b" access="readwrite">
      <!--Enables access to additional OEM acpi features.-->
    </property>
    <property name="os" type="s" access="readwrite"/>
    <property name="ovf-transport-iso" type="b" access="readwrite">
      <!--Transport of OVF configuration via iso enabled yes/no.-->
    </property>
    <property name="pae" type="b" access="readwrite"/>
    <property name="passthrough-io" type="s" access="readwrite"/>
    <property name="passthrough-mmio" type="s" access="readwrite"/>
    <property name="policy-audio-access" type="b" access="readwrite">
      <!--Allow to playback audio.-->
    </property>
    <property name="policy-audio-recording" type="b" access="readwrite">
      <!--Allow to record audio.-->
    </property>
    <property name="policy-cd-access" type="b" access="readwrite">
      <!--Allow to read from CD.-->
    </property>
    <property name="policy-cd-recording" type="b" access="readwrite">
      <!--Allow to record CD.-->
    </property>
    <property name="policy-modify-vm-settings" type="b" access="readwrite">
      <!--Allow modification of VM settings.-->
    </property>
    <property name="policy-print-screen" type="b" access="readwrite">
      <!--Allow VM to use the PrintScreen key.-->
    </property>
    <property name="policy-wired-networking" type="b" access="readwrite">
      <!--Allow to access wired network.-->
    </property>
    <property name="policy-wireless-networking" type="b" access="readwrite">
      <!--Allow to access wireless network.-->
    </property>
    <property name="portica-enabled" type="i" access="read"/>
    <property name="portica-installed" type="b" access="read"/>
    <property name="preserve-on-reboot" type="b" access="readwrite">
      <!--After reboot, keep the vm in rebooted state instead of automatically restarting it-->
    </property>
    <property name="private-space" type="i" access="read">
      <!--Private space used (in MiB).-->
    </property>
    <property name="provides-default-network-backend" type="b" access="readwrite">
      <!--Whether this domain is the primary networking backend and handles the physical NIC devices.-->
    </property>
    <property name="provides-graphics-fallback" type="b" access="readwrite">
      <!--System will keep this VM on screen when no better candidate is present.-->
    </property>
    <property name="provides-network-backend" type="b" access="readwrite">
      <!--Whether this domain is a networking backend and handles the physical nic devices.-->
    </property>
    <property name="pv-addons" type="b" access="readwrite"/>
    <property name="pv-addons-version" type="s" access="readwrite"/>
    <property name="qemu-dm-path" type="s" access="readwrite"/>
    <property name="qemu-dm-timeout" type="i" access="readwrite">
      <!--Timeout (in seconds) to wait for qemu response during its startup.-->
    </property>
    <property name="ready" type="b" access="readwrite">
      <!--Is VM ready for use?-->
    </property>
    <property name="realm" type="s" access="readwrite">
      <!--Realm ID.-->
    </property>
    <property name="restrict-display-depth" type="b" access="readwrite">
      <!--Restrict available display depths. Currently required by emulated VGA in Windows 8.-->
    </property>
    <property name="restrict-display-res" type="b" access="readwrite">
      <!--Restrict available display resolutions.-->
    </property>
    <property name="run-insteadof-start" type="s" access="readwrite">
      <!--Command to run instead of VM start-->
    </property>
    <property name="run-on-acpi-state-change" type="s" access="readwrite">
      <!--Command to run on VM acpi state change.-->
    </property>
    <property name="run-on-state-change" type="s" access="readwrite">
      <!--Command to run on VM state change.-->
    </property>
    <property name="run-post-create" type="s" access="readwrite">
      <!--Command to run post VM creation.-->
    </property>
    <property name="run-pre-boot" type="s" access="readwrite">
      <!--Command to run synchronously pre VM boot.-->
    </property>
    <property name="run-pre-delete" type="s" access="readwrite">
      <!--Command to run pre VM deletion.-->
    </property>
    <property name="s3-mode" type="s" access="readwrite">
      <!--Configure how the VM is put to sleep.-->
    </property>
    <property name="s4-mode" type="s" access="readwrite">
      <!--Configure how the VM is hibernated.-->
    </property>
    <property name="seamless-id" type="s" access="readwrite">
      <!--Handle seamless uses to reference the VMs.-->
    </property>
    <property name="seamless-mouse-left" type="i" access="read">
      <!--Where to move mouse when it goes over left edge.-->
    </property>
    <property name="seamless-mouse-right" type="i" access="read">
      <!--Where to move mouse when it goes over right edge.-->
    </property>
    <property name="seamless-traffic" type="b" access="readwrite"/>
    <property name="secureboot" type="b" access="readwrite">
      <!--Enable or disable Secure Boot mode in UEFI guest VMs.-->
    </property>
    <property name="serial" type="s" access="readwrite">
      <!--Serial port specification-->
    </property>
    <property name="show-switcher" type="b" access="readwrite">
      <!--Hide/show switcher bar inside VM.-->
    </property>
    <property name="shutdown-priority" type="i" access="readwrite">
      <!--Controls order of vm shutdown, higher priority means earlier shutdown. For new VMs defaults to 0, or -10 in case of PVM. VMs with same priority are shutdown in parallel.-->
    </property>
    <property name="slot" type="i" access="readwrite"/>
    <property name="sound" type="s" access="readwrite"/>
    <property name="start-from-suspend-image" type="s" access="readwrite">
      <!--Start the VM from the suspend image file, if it exists.-->
    </property>
    <property name="start-on-boot" type="b" access="readwrite"/>
    <property name="start-on-boot-priority" type="i" access="readwrite">
      <!--Control priority of start-on-boot VMs, higher priority means earlier start. For new VMs this defaults to 0.-->
    </property>
    <property name="state" type="s" access="read"/>
    <property name="stubdom" type="b" access="readwrite">
      <!--Use stub domain to hide the device emulator.-->
    </property>
    <property name="stubdom-cmdline" type="s" access="readwrite">
      <!--Cmdline to be appended to the stubdomain's default cmdline.-->
    </property>
    <property name="stubdom-flask-label" type="s" access="readwrite"/>
    <property name="stubdom-memory" type="i" access="readwrite">
      <!--Memory given to the stubdomain, in megabytes.-->
    </property>
    <property name="sync-uuid" type="s" access="readwrite">
      <!--VM UUID in Synchroniser space.-->
    </property>
    <property name="time-offset" type="i" access="readwrite"/>
    <property name="timer-mode" type="s" access="readwrite">
      <!--Domain timer mode-->
    </property>
    <property name="track-dependencies" type="b" access="readwrite">
      <!--If true, automatically start required VMs.-->
    </property>
    <property name="type" type="s" access="readwrite"/>
    <property name="usb-auto-passthrough" type="b" access="readwrite">
      <!--Enables automatic passthrough of new USB devices to VM currently in focus upon plugging in.-->
    </property>
    <property name="usb-control" type="b" access="readwrite">
      <!--Enables VM to talk to USB daemon-->
    </property>
    <property name="usb-enabled" type="b" access="readwrite">
      <!--Enables PV USB support.-->
    </property>
    <property name="usb-grab-devices" type="b" access="readwrite">
      <!--Automatically assign all available USB devices upon this VM start.-->
    </property>
    <property name="uuid" type="s" access="read"/>
    <property name="vcpus" type="i" access="readwrite"/>
    <property name="videoram" type="i" access="readwrite"/>
    <property name="viridian" type="b" access="readwrite"/>
    <property name="virt-type" type="s" access="readwrite"/>
    <property name="vkbd" type="b" access="readwrite">
      <!--Use PV keyboard and mouse.-->
    </property>
    <property name="vsnd" type="b" access="readwrite">
      <!--Use PV audio device.-->
    </property>
    <property name="wired-network" type="s" access="readwrite"/>
    <property name="wireless-control" type="b" access="readwrite">
      <!--Give VM control over wireless stack.-->
    </property>
    <property name="wireless-network" type="s" access="readwrite"/>
    <property name="xci-cpuid-signature" type="b" access="readwrite">
      <!--Advertise the guest as XenClient flavour of Xen.-->
    </property>
  </interface>
</node>
